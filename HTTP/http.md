##### 常见状态码
```
200 OK：请求成功，服务器成功处理了请求。

204 No Content：服务器成功处理了请求，但没有返回任何内容。

301 Moved Permanently：请求的资源已永久移动到新的URL。

302 Found：请求的资源暂时移动到新的URL。

304 Not Modified：客户端发送了条件请求，服务器返回资源未修改，可以直接使用缓存。

400 Bad Request：服务器无法理解请求的语法或参数。

401 Unauthorized：请求需要身份验证，但用户未提供有效的身份凭证。

403 Forbidden：服务器拒绝请求访问资源，权限不足。

404 Not Found：请求的资源不存在。

500 Internal Server Error：服务器内部错误，无法完成请求。

501 当前请求方式不支持

502 Bad Gateway：作为代理或网关的服务器从上游服务器接收到无效的响应。

503 Service Unavailable：服务器暂时无法处理请求，通常由于过载或维护。
```

##### 1.下次 请求不缓存 强制刷新
```
- GET请求能缓存，POST不能
- 后端在header头中配置
- cache-control: no-cache, no-store, max-age=0, must-revalidate
- 在ios中跳h5公众号h5页面，回来还是会缓存，请求上设置随机值 timestamp:new Date().getTime(),
```

##### 2. http差异（https://juejin.cn/post/7149438206419664927）
```
  HTTP 1.0 和 HTTP 1.1 之间有哪些区别？
    连接方面：
      - 1.0 默认使用非持久链接 
      - 1.1 持久链接（后面的请求必须等待上一个请求响应后才能进行，会造成请求堵塞）
    
    资源请求方面：
      - 1.0 不支持断点续传 浪费带宽（需要某个对象一部分，却将整个对象传输）
      - 1.1 引入range允许只请求资源某部分

    1.1新增
      - 缓存：引入更多可选择缓存头控制缓存
      - 请求方法：新增put head options等
      - host字段 主要用来实现虚拟主机技术，用来指定服务器（http1.0认为一台服务器绑定一个ip地址，）

    host栗子：有一台 ip 地址为 61.135.169.125 的服务器，在这台服务器上部署着谷歌、百度、淘宝的网站。为什么我们访问https://www.google.com看到的是百度的首页，原因就是host请求头决定着访问哪个虚拟主机。

    虚拟主机（virtual hosting）即共享主机（shared web hosting），可以利用虚拟技术把一台完整的服务器分成若干个主机，因此可以在单一主机上运行多个网站或服务。


  HTTP 1.1 和 HTTP 2.0 之间有哪些区别？
    二进制协议：
      - 1.1 报文头部必须是文本（ASCLL），数据体文本或二进制
      - 2.0 都是二进制

    2.0新增
      - 多路复用：复用tcp连接，在连接中，客户端和服务端可以同时发送多个请求（而且不用按照顺序发送，避免的'队头堵塞'问题）
      - 数据流：数据包不按顺序发送，同一个连接（复用的tcp连接）连续的数据包，可能是不同请求的，因此数据包都有标记并标记自己属于哪个请求，将每个请求或回应的所有数据包称为一个数据流。每个数据流都有独一无二的编号，数据包发送都必须标记数据流id，用来区分它属于哪个数据流。
      - 服务器推送：允许服务器未经请求，主动向客户端发送资源（只能推送静态资源）
      - 头部信息压缩：头部使用gzip或compress压缩后在发送

    HTTP/2 引入了流（stream）和帧（frame）的概念。（https://zhuanlan.zhihu.com/p/555785707）
      - 帧：是最小的数据单位，HTTP 报文不再是原来的明文的 ASCII 编码，而是会被拆分成一个个的二进制形式的帧。帧上面除了 HTTP 数据，还包含数据长度、流标识符、帧类型等信息。

      - 流：是一个建立连接后的双向的虚拟字节流，可以承载多个消息。帧通过自己的流 ID，确定自己属于哪个报文，就可以不按顺序进行请求响应了。

    HTTP/2 会将所有 HTTP 请求打散成帧，在一个 TCP 连接上做并发请求，充分利用 TCP 带宽。现在浏览器对于 HTTP2，只会建立一个 TCP 连接，减轻了服务端不小压力。
```

##### 3.什么是队头堵塞，怎么解决（https://zhuanlan.zhihu.com/p/575603813）
```
  原因（http1.x有的问题，并发数有限制）：
    http规定报文必须是“一发一收”，这就形成了一个先进先出的队列，如果排在前面的请求因为种种原因导致太慢，那么后面的请求也不得不跟着一起等待，结果就是其他请求承担了不应有的时间成本，造成了“队头堵塞”的现象
  
  解决：
    - 并发连接：对一个域名允许分配多个长链接
    - 域名分片：将域名分出很多二级域名并指向同一台服务器，这样能够并发的长链接变多
```

##### 4.`http`和`https`的区别
```
  - 证书：https需要
  - 安全性：http明文传输，https使用ssl加密传输协议
  - 端口：http 80端口 https：443端口
  - http协议连接是简单无状态，https协议是有ssl和http协议构建的可进行加密传输、身份认证的网络协议，比http安全。

  https缺点：
    - 握手比较费时
    - 面对DDOS攻击时，起不到任何作用
```

##### 5.一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么（https://juejin.cn/post/7149438206419664927）
```
  简单：
    - 1.浏览器地址栏输入 URL 并回车
    - 2.游览器查找当前url是否存在缓存，并比较是否过期
    - 3.DNS解析url 对应的ip
    - 4.根据ip建立TCP连接（三次握手）
    - 5.发送http请求
    - 6 服务器处理请求，游览器接受http响应
    - 7.游览器解析并渲染页面
    - 8.关闭TCP连接（四次挥手）

  详解：
  - 1.解析URL
      - 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径，如果不合法将内容传递给搜索引擎
  - 2.缓存判断
      - 判断所请求资源是否在缓存中，如果在缓存中并且没有失效则直接使用，否则发起请求
  - 3.DNS解析（用户向本地DNS服务器发送的请求属于递归请求，本地DNS服务器向各级域名服务器发送的请求属于迭代请求）
      - 判断本地host是否有该域名的ip地址缓存，有则使用
      - 没有则向本地DNS服务器发起请求，本地DNS服务器也会先检查是否存在缓存
      - 最后迭代查询（ 按根域名 -> 顶级域名 -> 权威服务器）最后获取域名的ip地址
        - 没有则向根域名服务器发起请求，获取负责的顶级域名服务器的地址后
        - 再向顶级域名服务器请求，获得负责的权威域名服务器的地址后
        - 再向权威域名服务器请求，最终获得域名的ip地址
      - 本地DNS在将这个ip地址返回给请求的用户
  - 4.根据ip建立TCP连接（三次握手）
  - 5.发起请求，服务器处理请求，返回响应报文，游览器接受
  - 6.页面渲染构建DOM树
      - 游览器根据响应的html文件构建 DOM 树
      - 根据解析的css 构建 CSSOM树
      - 之后根据它两构建渲染树，进行布局和绘制
  - 7.保持连接或关闭TCP连接（四次挥手）
```

