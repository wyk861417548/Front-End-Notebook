#### 1.常见状态码
```
200 OK：请求成功，服务器成功处理了请求。

204 No Content：服务器成功处理了请求，但没有返回任何内容。

301 Moved Permanently：请求的资源已永久移动到新的URL。

302 Found：请求的资源暂时移动到新的URL。

304 Not Modified：客户端发送了条件请求，服务器返回资源未修改，可以直接使用缓存。

400 Bad Request：服务器无法理解请求的语法或参数。

401 Unauthorized：请求需要身份验证，但用户未提供有效的身份凭证。

403 Forbidden：服务器拒绝请求访问资源，权限不足。

404 Not Found：请求的资源不存在。

500 Internal Server Error：服务器内部错误，无法完成请求。

501 当前请求方式不支持

502 Bad Gateway：作为代理或网关的服务器从上游服务器接收到无效的响应。

503 Service Unavailable：服务器暂时无法处理请求，通常由于过载或维护。
```

#### 2.下次 请求不缓存 强制刷新
```
- GET请求能缓存，POST不能
- 后端在header头中配置
- cache-control: no-cache, no-store, max-age=0, must-revalidate
- 在ios中跳h5公众号h5页面，回来还是会缓存，请求上设置随机值 timestamp:new Date().getTime(),
```

#### 3.http差异?[参考](https://juejin.cn/post/7149438206419664927)
###### HTTP 1.0 和 HTTP 1.1 之间有哪些区别？
```
连接方面：
  - 1.0 默认使用非持久链接 
  - 1.1 持久链接（后面的请求必须等待上一个请求响应后才能进行，会造成请求堵塞）

资源请求方面：
  - 1.0 不支持断点续传 浪费带宽（需要某个对象一部分，却将整个对象传输）
  - 1.1 引入range允许只请求资源某部分

1.1新增
  - 缓存：引入更多可选择缓存头控制缓存
  - 请求方法：新增put head options等
  - host字段 主要用来实现虚拟主机技术，用来指定服务器（http1.0认为一台服务器绑定一个ip地址，）
```
>host栗子：有一台 ip 地址为 61.135.169.125 的服务器，在这台服务器上部署着谷歌、百度、淘宝的网站。为什么我们访问https://www.google.com看到的是百度的首页，原因就是host请求头决定着访问哪个虚拟主机。

虚拟主机（virtual hosting）即共享主机（shared web hosting），可以利用虚拟技术把一台完整的服务器分成若干个主机，因此可以在单一主机上运行多个网站或服务。

###### HTTP 1.1 和 HTTP 2.0 之间有哪些区别？
简单
```
  二进制分帧
  请求多路复用 (Stream/Frame)
  头部压缩: (HPack)
  服务端推送: (PUSH_PROMISE)
```
详解
```
二进制协议：
  - 1.1 报文头部必须是文本（ASCLL），数据体 文本或二进制
  - 2.0 都是二进制

2.0新增
  - 多路复用：复用tcp连接，在连接中，客户端和服务端可以同时发送多个请求（而且不用按照顺序发送，避免的'队头堵塞'问题）

  - 数据流：数据包不按顺序发送，同一个连接（复用的tcp连接）连续的数据包，可能是不同请求的，因此数据包都有标记并标记自己属于哪个请求，
  将每个请求或回应的所有数据包称为一个数据流。每个数据流都有独一无二的编号，数据包发送都必须标记数据流id，用来区分它属于哪个数据流。

  - 服务器推送：允许服务器未经请求，主动向客户端发送资源（只能推送静态资源）

  - 头部信息压缩：头部使用gzip或compress压缩后在发送
```
HTTP/2 引入了流（stream）和帧（frame）的概念。[参考](https://zhuanlan.zhihu.com/p/555785707)

  - 帧：是最小的数据单位，HTTP 报文不再是原来的明文的 ASCII 编码，而是会被拆分成一个个的二进制形式的帧。帧上面除了 HTTP 数据，还包含数据长度、流标识符、帧类型等信息。

  - 流：是一个建立连接后的双向的虚拟字节流，可以承载多个消息。帧通过自己的流 ID，确定自己属于哪个报文，就可以不按顺序进行请求响应了。

HTTP/2 会将所有 HTTP 请求打散成帧，在一个 TCP 连接上做并发请求，充分利用 TCP 带宽。现在浏览器对于 HTTP2，只会建立一个 TCP 连接，减轻了服务端不小压力。


#### 4.什么是队头堵塞，怎么解决?[参考](https://zhuanlan.zhihu.com/p/575603813)
```
  原因（http1.x有的问题，并发数有限制）：
    http规定报文必须是“一发一收”，这就形成了一个先进先出的队列，如果排在前面的请求因为种种原因导致太慢，那么后面的请求也不得不跟着一起等待，结果就是其他请求承担了不应有的时间成本，造成了“队头堵塞”的现象
  
  解决：
    - 并发连接：对一个域名允许分配多个长链接
    - 域名分片：将域名分出很多二级域名并指向同一台服务器，这样能够并发的长链接变多
```

#### 5.`http`和`https`的区别
```
  - 证书：https需要
  - 安全性：http明文传输，https使用ssl加密传输协议
  - 端口：http 80端口 https：443端口
  - http协议连接是简单无状态，https协议是有ssl和http协议构建的可进行加密传输、身份认证的网络协议，比http安全。

  https缺点：
    - 握手比较费时
    - 面对DDOS攻击时，起不到任何作用
```

#### 6.一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？[参考](https://juejin.cn/post/7149438206419664927)
简单：
```
  - 1.浏览器地址栏输入 URL 并回车
  - 2.游览器查找当前url是否存在缓存，并比较是否过期
  - 3.DNS解析url 对应的ip
  - 4.根据ip建立TCP连接（三次握手）
  - 5.发送http请求
  - 6 服务器处理请求，游览器接受http响应
  - 7.游览器解析并渲染页面
  - 8.关闭TCP连接（四次挥手）
```
详解：
```
  - 1.解析URL
      - 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径，如果不合法将内容传递给搜索引擎
  - 2.缓存判断
      - 判断所请求资源是否在缓存中，如果在缓存中并且没有失效则直接使用，否则发起请求
  - 3.DNS解析（用户向本地DNS服务器发送的请求属于递归请求，本地DNS服务器向各级域名服务器发送的请求属于迭代请求）
      - 判断本地host是否有该域名的ip地址缓存，有则使用
      - 没有则向本地DNS服务器发起请求，本地DNS服务器也会先检查是否存在缓存
      - 最后迭代查询（ 按根域名 -> 顶级域名 -> 权威服务器）最后获取域名的ip地址
        - 没有则向根域名服务器发起请求，获取负责的顶级域名服务器的地址后
        - 再向顶级域名服务器请求，获得负责的权威域名服务器的地址后
        - 再向权威域名服务器请求，最终获得域名的ip地址
      - 本地DNS在将这个ip地址返回给请求的用户
  - 4.根据ip建立TCP连接（三次握手）
  - 5.发起请求，服务器处理请求，返回响应报文，游览器接受
  - 6.页面渲染构建DOM树
      - 游览器根据响应的html文件构建 DOM 树
      - 根据解析的css 构建 CSSOM树
      - 之后根据它两构建渲染树，进行布局和绘制
  - 7.保持连接或关闭TCP连接（四次挥手）
```

#### 7.游览器缓存机制？
**自我调试可见: 强缓存文件夹 和 协商缓存文件夹**

强缓存：
```
通过设置Expires时间 和 Cache-Control 的 max-age等配置
```

协商缓存:
```
- 1.ETag（服务端） 和 if-none-match（来自游览器传值）
  通过比对文件内容有没有改变（获取文件的md5字）

- 2.Last-modified 和 if-modified-since
  通过比对文件上次修改时间（获取文件最后修改的时间）
```

#### 8.如果 http 响应头中 ETag 值改变了，是否意味着文件内容一定已经更改
不一定，由服务器中 ETag 的生成算法决定（服务器可以根据资源内容、修改时间等生成 ETag 值）。
```
- 例如：
  - 1.服务器的 ETag 生成算法发生了变化
  - 2.资源的元数据改变：当资源的元数据，比如修改时间（Last-Modified），权限等发生变化时，ETag 的值也可能会改变。
  - 3.代理服务器或 CDN 的缓存策略：当资源经过代理服务器或 CDN 时，它们可能会在缓存中保留资源的副本，并为资源生成新的 ETag。
```

#### 9.什么是gzip
简单来说：gzip 的核心是 Deflate，而它使用了 LZ77 算法与 Huffman 编码来压缩文件，重复度越高的文件可压缩的空间就越大。

原理：
```
 gzip 使用 DEFLATE 算法对文件进行压缩。该算法在服务器端将原始文本内容转换为压缩后的二进制数据，然后在客户端接收到压缩的数据后，再将其解压还原为原始的文本内容。这样可以在网络传输中减少文件的传输大小，从而提高传输速度。
```
因此 gzip 用于 HTTP 文件传输中，比如 JS、CSS 等，但一般不会压缩图片(如果开启的话，有可能使图片变的更大)。在 HTTP Response 报文中，用 Content-Encoding 指明使用 gzip 压缩，而以下响应头在大部分生产环境的响应报文中都可以看到！比如你现在立刻马上可以者百度试一试。

```
# Request Header
Accept-Encoding: gzip, deflate, br
 
# Reponse Header
Content-Encoding: gzip
```

#### 10.在发送 http 请求报文时，Host 是必要的吗?
必需的,在客户端发送 HTTP 请求时，需要在请求头中包含 Host 字段，以便服务器能够根据 Host 字段的值找到正确的虚拟主机或域名，并处理对应的请求。

#### 11.什么是xss攻击？如果防范？
xss攻击
>指的是跨站脚本攻击，是一种代码注入攻击，攻击者通过在网站注入恶意脚本，使之在用户的游览器上运行，从而获取用户信息

本质
>是网站没有对恶意脚本进行过滤，导致与正常代码混合在一起，而游览器无法分辨哪些脚本是可信的。

类型
```
- 存储型：是指提交到网站数据库中，但用户请求数据的时候，服务器将其拼接为html返回给用户，从而导致恶意代码执行

- 反射型：是指攻击者构建了特殊的url，当服务器接收到请求后，从url中获取数据，拼接到html后返回，从而导致恶意代码执行

- dom型：是指攻击者构建了特殊的url，用户打开网站后，js脚本从url中获取数据，从而导致恶意代码执行。
```
差异
```
- 反射型和存储型的区别是存储型存在数据库中，反射型存储在url中

- dom型 和 其他两种的区别是，dom型取出和执行恶意代码都是前端执行，属于前端javascript的漏洞，另外两种属于服务端漏洞
```

防范：xss攻击防范从两方面入手，一个是恶意代码提交时，一个是游览器执行
```
- 我们对存入数据库的数据进行转义处理，但是有的数据不止一个地方使用，有些地方使用又不需要转义，所以不可靠。所以我们可以使用游览器执行来进行预防，

  - 一种是使用纯前端，不用服务端拼接返回。
  
  - 另一种是对插入到html中的代码进行充分的转义
```

还有一些方式：
- 使用**csp**（即白名单），告诉游览器外部哪些资源可以加载执行，从而防止恶意脚本的注入攻击。
- 对敏感信息进行保护，比如对cookie设置httpOnly 防止脚本获取，也可以使用验证码，避免脚本伪造用户操作。


#### 12.什么情况下会发送 OPTIONS 请求
>当一个请求跨域且不是简单请求时就会发送 OPTIONS 请求

满足以下条件就是一个简单请求:
```
- 1.Method: 请求的方法是 GET、POST 及 HEAD

- 2.Header: 请求头是 Content-Type、Accept-Language、Content-Language 等

- 3.Content-Type: 请求类型是 application/x-www-form-urlencoded、multipart/form-data 或 text/plain
```
而在项目中常见的 Content-Type: application/json 及 Authorization: <token> 为典型的非简单请求，在发送请求时往往会带上 Options

