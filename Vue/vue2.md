##### 1.请说一下 vue2 响应式原理
```
- 简单来说: vue2 基于Object.defineProperty对数据进行劫持

- 从源码角度：使用initData对数据进行初始化操作，然后调用observe函数并实例化observer类，内部对所有属性进行了重写，并递归劫持了对象中的对象

- 所以我们在使用vue的时候，如果数据层级过深要注意优化，如果不是响应式的就不要放在data中，要避免多次取值，还可以使用Object.freeze()来冻结对象
```

##### 2."Vue"中怎么检测数组的变化？
```
- vue2并没有采用Object.defineProperty来进行劫持，因为会耗费大量性能，而是采用重写数组的变异方法来实现（函数劫持）

- 实现：
对所有的数组都新增了了一个dep收集器进行依赖收集，然后对数组的7种方法进行函数劫持重写，实际里面还是调用了数组原来的方法，通过监听到7种方法的调用（如果是push、unshift、splice的添加操作，还要对其添加的属性进行劫持操作），最后通知页面更新。
```

##### 3.vue中如何进行依赖收集？
```
- 所谓的依赖收集（观察者模式）被观察者指代理的数据（使用dep去收集）,观察者（渲染watcher 计算属性，用户watcher），一个watcher中可能对应着多个数据，watcher中还需要保存dep。

- 实现：
在属性初始化时通过给每个属性增加一个dep收集器，默认渲染页面的时候会进行依赖收集（会触发属性的get方法,因此也只会对页面上渲染的属性进行依赖收集）

> 多对多的关系
（每个属性都有一个dep  watcher相当一个视图）
一个组件中 有多个属性（n个属性形成一个视图） n个dep对应一个watcher
一个属性对应着多个组件 1个dep对应着多个watcher 
dep 和 watcher 多对多的关系
```


##### 4.如何理解 vue 中的编译原理
通过将template模板 变为 render函数

- template -> ast树
- 对语法树进行节点标记
- 将ast语法书生成render函数

>调用render生成虚拟节点，再通过update方法进行更新

##### 5.vue生命周期钩子是如何实现的？
内部就是利用了一个发布订阅模式，将用户写的钩子维护成了一个个数组（主要靠的是mergeOptions）
后续调用一次callHook就讲对应的钩子数组遍历执行

##### 6.为什么有些钩子是先子后父，有些是先父后子，组件是如何渲染的？
先父后子（beforeCreate 和 create）因为这两个钩子写在模板初始化之前
先子后父 （mount ）是因为在模板解析中如果遇到子组件会先解析玩子组件，然后再去解析父组件


##### 21.vue组件间传值的方式及之间区别
- props 父传递数据给儿子 原理就是把解析后的props验证后，将属性定义在当前的实例上vue._props（这个对象上的属性都是通过defineReactive来定义的 都是响应式的 组件在渲染的过程中湖区vm上取值 _props 属性会被代理到vm上）

- emit 儿子出发组件更新 在创建虚拟节点的时候将所有的事件绑定到了listeners，通过$on方法绑定事件，通过$emit方法来触发事件（发布订阅模式）
- events bus 原理就是发布订阅模式 $bus = new Vue()简单的通讯可以采用这种模式
- $parent $children 就是在创建子组件的时候，会将父组件的实例传入，在组件本身初始化时候会构建组件间的父子关系 $parent获取父组件实例 通过$children获取所有子组件的实例




##### 28.如何理解自定义指令
- 自定义指令就是用户定义好对应的钩子，当元素在不同的状态时，会调用对应的钩子（所有的钩子都会被合并到cbs对应的方法上，到时候依次调用）